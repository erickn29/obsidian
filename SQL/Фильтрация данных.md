
Итак, раньше мы уже научились доставать все записи из таблицы авторов.

Но что если нам надо выбрать одного автора по его идентификатору? Вот у нас в rroom будет, например, страничка конкретного автора с информацией об этом авторе. В URL этой странички будет зашит идентификатор этого автора и наша серверная программа должна будет по этому идентификатору достать информацию об этом авторе из нашей базы данных.

Например, адрес странички будет такой: [https://rroom.io/author/1](https://rroom.io/author/1), где `1` — это как раз идентификатор автора. Наша серверная программа видит этот идентификатор и, используя его, составляет SQL-запрос в базу данных для получения информации по этому автору.

Какой SQL-запрос мы можем написать для получения конкретной записи по идентификатору? Очень простой:

```sql
select * from author where author_id=1;
```

Ключевое слово `WHERE` означает фильтрацию, то есть достань мне все записи из таблички авторов, где поле `author_id = 1`. И у нас возвращается ровно одна запись, для которой этот идентификатор равен `1`. Отлично!

При этом конечно мы можем фильтровать не только по полю идентификатора, но и по любому другому полю точно так же. Например, давайте достанем автора с именем Михаил Шолохов по его имени:

```sql
select * from author where name='Михаил Шолохов';
```

Здорово!

Можно указывать одновременно несколько условий, например, мы можем выбрать все записи, у которых имя равно Михаил Шолохов и идентификатор равен одному:

```sql
select * from author where name='Михаил Шолохов' and author_id=1;
```

Здесь база данных проверит строки таблицы авторов на наше условие и оставит только те записи, которые соответствуют нашему условию. В данном случае, поле `name` должно иметь значение «Михаил Шолохов» **И** поле `author_id` должно иметь значение `1`. Вот она — наша логическая операция И из булевой алгебры, которую мы в прошлом уроке вспоминали. Если мы переведём слово «И» с русского языка на английский, то получится как раз `AND`.

Если мы подставим идентификатор другой, то подходящих записи не найдётся и сервер базы данных вернёт пустой ответ:

```sql
select * from author where name='Михаил Шолохов' and author_id=200;
```

Также вместо условия `AND`, что, повторюсь, означает И, можно использовать `OR`, что означает ИЛИ:

```sql
select * from author where name='Михаил Шолохов' or author_id=200;
select * from author where name='Михаил Шолохов' or name='Лусиану Рамальо';
```

Можно даже в условии указать `TRUE` или `FALSE`, что переводится как правда и ложь соответственно:

```sql
select * from author where name='Михаил Шолохов' or false;
select * from author where name='Михаил Шолохов' or true;
```

В первом случае условие `or false` избыточно, оно ни на что не влияет. Во втором случае наоборот условие `name='Михаил Шолохов'` избыточно и ни на что не влияет, так как второе условие имеет значение `TRUE` и используется логическая операция `OR`, то есть ИЛИ. Мы помним, что, если хотя бы один операнд в логической операции ИЛИ правдив, то и результат логической операции тоже правдив.

Зачем я вам это показываю? Вот эти `or false`? Просто для понимания того, как всё работает, как работают условия в SQL и в языках программирования. На практике вы в своих запросах не будете писать `or true` или `or false`, ну, если только в целях какого-то экспериментирования — или эксплуатации уязвимости SQL Injection, о чём поговорим в главе по информационной безопасности.

Отлично!

Ещё стоит упомянуть `NOT`, отрицание, этот оператор превращает правду в ложь и наоборот. Например, мы можем достать все записи, у которых идентификатор не равен `1` вот такими тремя разными способами:

```sql
select * from author where not author_id = 1;
select * from author where author_id != 1;
select * from author where author_id <> 1;
```

В первом случае мы указываем `NOT`, что означает отрицание далее идущего условия. Во втором (!=) и третьем (<>) случае мы вместо равно указывает не равно, это просто 2 разных синтаксиса указать не равно, можете использовать любой.

Так, здесь мы везде указываем равно, или вот не равно, но есть ещё операторы сравнения:

```sql
select * from author where author_id < 2;
select * from author where author_id <= 2;
select * from author where author_id > 2;
```

Также есть оператор `BETWEEN`:

```sql
select * from author where author_id between 1 and 2;
```

Как видим, `BETWEEN` включает в себя обе границы, то есть этот запрос с `BETWEEN` идентичен этому:

```sql
select * from author where author_id >= 1 and author_id <= 2;
```

Конечно, вместо 1 и 2 могут быть любые другие значения.

Ещё стоит сказать про оператор `IN`, он проверяет, что значение входит в набор значений, то есть совпадает с каким-то значением в наборе. `IN` переводится как «в»:

```sql
select * from author where author_id in (1, 2, 3, 4, 5);
```

Это работает не только для чисел, но и для других типов данных, например, для строк.

Причём `IN` может работать с подзапросами:

```sql
select * from author where author_id in (
    select author_id from book
);

select * from author where author_id in (
    select author_id from book where name='Тихий Дон'
);
```

Подзапрос возвращает набор данных и внешний запрос здесь использует результат работы внутреннего подзапроса для проверки условия `IN`.

И, наконец, ещё есть оператор `LIKE`:

```sql
select * from author where name like '%Шолохов%';
select * from author where name like '%Михаил%';
select * from author where name like '%аил%';
```

Как работает этот оператор. Символу `%` соответствует ноль или больше символов. То есть шаблон `%Шолохов%` означает — ноль или больше символов, затем `Шолохов`, затем ноль или больше символов.

Вот так не работает:

```sql
select * from author where name like 'Шолохов';
```

Потому что тут нет процентов, и у нас нет книг, для которых поле name равно строке `Шолохов`. Так работает:

```sql
select * from author where name like 'Михаил Шолохов';
```

Вот такой запрос вернет все строки, для которых name начинается на `Михаил`:

```sql
select * from author where name like 'Михаил%';
```

Заканчивается на Шолохов:

```sql
select * from author where name like '%Шолохов';
```

Содержит в начале, внутри или в конце строки буквы `ол`:

```sql
select * from author where name like '%ол%';
```

Помимо `%` есть ещё один спец символ `_`, который означает ровно один символ:

```sql
select * from author where name like '_ихаил%';
select * from author where name like '___ихаил%';
```

На практике, по-моему, я ни разу не использовал его в запросах, но возможно где-то он и будет полезен.

Есть ещё удобный оператор `ILIKE`, который соответствует регистронезависимому поиску:

```sql
select * from author where name ilike '%михаил%';
select * from author where name ilike '%миХАил%';
```

Также работает поиск по регулярным выражениям:

```sql
select name from book where name ~ '^\w+\W+\w+$';
```

Этот запрос выберет все книги, названия которых состоят из двух слов.

[[SQL]]
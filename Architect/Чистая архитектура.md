Еще в 2000-ом году [Роберт Мартин](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%82%D0%B8%D0%BD,_%D0%A0%D0%BE%D0%B1%D0%B5%D1%80%D1%82_(%D0%B8%D0%BD%D0%B6%D0%B5%D0%BD%D0%B5%D1%80)) (так же известный как Дядюшка Боб) в статье «[Принципы дизайна и проектирования](http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)» собрал воедино пять принципов проектирования [[ООП]] приложений под запоминающейся аббревиатурой [[SOLID]]. Данные принципы были хорошо приняты сообществом и вышли далеко за рамки экосистемы Java. Тем не менее они носят весьма абстрактный характер. Позже было несколько попыток выработать общий дизайн приложения, базирующийся на SOLID-принципах. К ним относится: «[[Гексагональная архитектура]]», «[[Порты и адаптеры]]», «[[Луковичная архитектура]]» и у всех у них много общего хоть и разные детали реализации. А в 2012 году вышла статья того же Роберта Мартина, где он предложил свой вариант под названием «[**Чистая архитектура**](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)».

По версии Дядюшки Боба, architect — это в первую очередь «**границы и барьеры**», необходимо четко понимать потребности и ограничивать программные интерфейсы для того, чтобы не потерять контроль за приложением. Для этого программа **делится на слои**. Обращаясь из одного слоя к другому, можно передавать **только данные** (в качестве данных могут выступать простые структуры и _DTO_ объекты) — это правило границ. Еще одна наиболее часто цитируемая фраза, о том, что «_приложение должно кричать_» — означает, что главным в приложении является не используемый [[фреймворк]] или технология хранения данных, а то, что собственно это приложение делает, какую функцию оно выполняет — **бизнес-логика** приложения. Поэтому слои имеют не линейную структуру, а **обладают иерархией**. Отсюда еще два правила:  
  

- _Правило приоритета внутреннего слоя_ — именно внутренний слой определяет интерфейс, через который он будет взаимодействовать с окружающим миром;
- _Правило зависимостей_ — зависимости должны быть направлены от внутреннего слоя к внешнему.

Последнее правило достаточно нетипично в мире [[python]]. Для применения сколько-нибудь сложного сценария бизнес-логики всегда нужно обращаться к внешним сервисам (например, [[SQL|БД]]), но, чтобы избежать этой зависимости, слой бизнес-логики должен сам объявить [[интерфейс]], по которому он будет взаимодействовать с внешним миром. Этот прием называется «**инверсией зависимостей**» (буква D в SOLID) и широко распространен в языках со статической типизацией. По мнению Роберта Мартина, это **основное преимущество, появившееся благодаря ООП**.  
  
Эти три правила и есть суть Clean Architecture:  
  

- Правило пересечения границ;
- Правило зависимостей;
- Правило приоритета внутреннего слоя.

К преимуществам данного подхода относится:  
  

- **Простота тестирования** — слои изолированы, соответственно, их можно [[тестировать]] без [[monkey-patching]], можно гранулярно устанавливать покрытие для разных слоев, в зависимости от степени их важности;
- **Простота изменения бизнес-правил**, так как все они собраны в одном месте, не размазаны по проекту и не перемешаны с низкоуровневым кодом;
- **Независимость от внешних агентов**: наличие абстракций между бизнес-логикой и  внешним миром в определенных случаях позволяет менять внешние источники, не затрагивая внутренние слои. Работает, если вы не завязали бизнес-логику на специфические особенности внешних агентов, например, [[транзакции]] БД;
- **Улучшение восприятия**, несмотря на то, что код размазывается на слои, высокоуровневый код не перемешивается с низкоуровневым.

Сейчас распространена связка [[pydantic]]/[[fastapi]], и интеграция с такими фреймворками стала намного проще. Вот так бы выглядел вышеуказанный пример restomatic/services.py:
```python
from typing import Optional, Listfrom pydantic import BaseModelclass 

class Room(BaseModel):   
	code: str   
	size: int   
	price: int   
	latitude: float   
	longitude: floatclass 
	
class RoomFilter(BaseModel):   
	code: Optional[str] = None   
	price_min: Optional[int] = None   
	price_max: Optional[int] = Noneclass 
	
class RoomStorage:   
	def get_rooms(self, filters: RoomFilter) -> List[Room]: ...
	
class RoomListUseCase:   
	def __init__(self, repo: RoomStorage):       
		self.repo = repo   
		
	def show_rooms(self, filters: RoomFilter) -> List[Room]:       
		rooms = self.repo.get_rooms(filters=filters)       
		return rooms
```
RoomListUseCase — класс, реализующий бизнес-логику проекта. Не стоит обращать внимание на то, что все, что делает метод show_rooms это обращение к RoomStorage (данный пример придумал не я). В реальной жизни здесь также может быть расчет скидки, ранжирование списка на основе рекламных объявлений и т.д. Тем не менее модуль является самодостаточным. Если мы захотим воспользоваться данным сценарием в другом проекте, нам придется реализовать RoomStorage. И что для этого нужно, здесь отлично видно прямо из модуля. В отличие от прошлого примера, такой слой **является самодостаточным**, и при изменении не обязательно держать в голове весь контекст. Из несистемных зависимостей только pydantic, почему, станет понятно в модуле подключения фреймворка. **Отсутствие зависимостей**, еще один способ повышения читаемости кода, не дополнительного контекста, даже начинающий разработчик сможет понять, что делает данный модуль.

А вот как выглядит подключение к фреймворку:  
  

```python
from typing import Listfrom fastapi import FastAPI, Dependsfrom rentomatic import services, adapters

app = FastAPI()

def get_use_case() -> services.RoomListUseCase:   
	return services.RoomListUseCase(adapters.MemoryStorage())
	
@app.post("/rooms", response_model=List[services.Room])
def rooms(filters: services.RoomFilter, use_case=Depends(get_use_case)):   
	return use_case.show_rooms(filters)
```

  
С помощью функции get_use_case в FastAPI реализуется паттерн _Dependency Injection_. Нам не нужно заботиться о сериализации данных, всю работу выполняет FastAPI в связке с pydantic. К сожалению, не всегда формат данных бизнес-логики подходит для прямой трансляции в рест< и, наоборот, **бизнес-логика не должна знать, откуда пришли данные — с урла, тела запроса, кук и т.д**. В этом случае в теле функции room будет некое преобразование входных и выходных данных, но в большинстве случаев, если мы работаем с [[API]], достаточно такой легкой прокси-функции.

Сам Роберт Мартин не раз говорил, что **количество слоев может меняться** как в большую, так и меньшую сторону. При этом проект отвечает основным критериям Clean Architecture:  
  

- **Правило пересечения границ**: границы пересекают pydantic модели, являющиеся по сути [[DTO]];
- **Правило зависимостей**: слой бизнес-логики не зависит от других слоев;
- **Правило приоритета внутреннего слоя**: именно слой бизнес-логики определяет интерфейс (RoomStorage), по которому осуществляется взаимодействие бизнес-логики с внешним миром.
Списки - коллекции других объектов

они могут изменяться на месте, увеличиваться и уменьшаться по требованию, а также содержать в себе и быть вложенными в объект любого другого вида.

В отличие от строк списки способны содержать объекты любого вида: числа, строки и даже другие списки. Также в отличие от строк списки можно модифицировать на месте путем присваивания по смещениям и по срезам, вызова списковых методов, выполнения операторов удаления и т.п. — они представляют собой изменяемые объекты

Они являются упорядоченными коллекциями произвольных объектов 

С точки зрения функциональности списки — это всего лишь места для накопления других объектов, так что их можно трактовать как группы. Списки также поддерживают позиционное упорядочение слева направо для содержащихся внутри них элементов (т.е. они представляют собой последовательности). 

Они поддерживают доступ по смещению 

Как и в случае строк, извлекать объект компонента из списка можно путем индексации списка по смещению объекта. Поскольку элементы в списке упорядочены по своим позициям, можно также выполнять такие операции, как нарезание и конкатенация. 

Они имеют переменную длину, разнородны и допускают произвольно глубокое вложение 

В отличие от строк списки способны увеличиваться и уменьшаться на месте (их длины могут варьироваться) и содержать объекты любых видов, а не только односимвольные строки (они разнородны). Из-за того, что списки могут содержать другие сложные объекты, они также поддерживают произвольно глубокое вложение; допускается создавать списки, содержащие списки списков и т.д. 

Они относятся к категории “изменяемая последовательность” 

В терминах категорий типов списки являются изменяемыми (т.е. могут быть модифицированы на месте) и способны реагировать на все операции над последовательностями, применяемые к строкам, такие как индексация, нарезание и конкатенация. На самом деле операции над последовательностями работают со списками так же, как со строками; разница лишь в том, что операции наподобие конкатенации и нарезания в случае использования со списками возвращают новые списки, а не новые строки. Однако поскольку списки изменяемы, они также поддерживают другие операции, не поддерживаемые строками, такие как удаление и присваивание по индексу, которые изменяют списки на месте. 

Они представляют собой массивы ссылок на объекты 

Формально списки Python содержат ноль и более ссылок на другие объекты. При наличии опыта работы с другими языками списки могут напоминать массивы указателей (адресов). Извлечение элемента из списка Python производится почти так же быстро, как индексация массива С; внутри стандартного интерпретатора списки в действительности представляют собой массивы, а не связные структуры. Тем не менее, как объяснялось в главе 6, всякий раз, когда ссылка используется, Python следует по ней на объект, поэтому программа имеет дело только с объектами. В случае присваивания объекта компоненту структуры данных или переменной Python всегда сохраняет ссылку на тот же самый объект, а не на его копию (если только копия не запрашивается явно). 

Поскольку списки являются последовательностями, они поддерживают многие операции, относящиеся к строкам. Скажем, списки реагируют на операции + и * почти как строки — упомянутые операции здесь также означают конкатенацию и повторение, но только результатом будет новый список, а не строка

Хотя операция + работает одинаково для списков и строк, важно знать, что она ожидает mom же самый вид последовательности с обеих сторон — иначе при запуске кода возникнет ошибка. Например, выполнить конкатенацию списка и строки не удастся, если сначала не преобразовать список в строку (используя такие инструменты, как str или форматирование %) или строку в список (посредством встроенной функции list):

Итерация по спискам и списковые включения 

Индексация, нарезание и матрицы

Поскольку списки изменяемы, они поддерживают операции, которые изменяют списковый объект на месте. То есть все операции в текущем разделе модифицируют списковый объект напрямую, переписывая его старое значение, и не требуют создания новой копии, как пришлось бы поступать в случае строк. Из-за того, что Python имеет дело только со ссылками на объекты, такое разграничение между изменением объекта на месте и созданием нового объекта является существенным; как обсуждалось в главе 6, изменение объекта на месте может оказать влияние более чем на одну ссылку на него.

Содержимое списка можно изменять, присваивая значение либо отдельному элементу (по смещению), либо целому сегменту (по срезу)

```python
»> L = [’spam', 'Spam', 'SPAM!']

>>> L[l] = 'eggs' # Присваивание по индексу 

»> L 

['spam', 'eggs', 'SPAM!'] 

»> L[0:2] = ['eat', 'more'] # Присваивание по срезу: удаление вставка 

»> L # Заменяет элементы 0,1 

['eat', 'more', 'SPAM!']
```

Присваивания по индексам и по срезам представляют собой изменения на месте — они модифицируют списковый объект напрямую, а не генерируют для результата новый списковый объект. Присваивание по индексу в Python работает почти как в С и большинстве других языков: [[Python]] заменяет одиночную ссылку на объект, находящуюся по заданному смещению, новой ссылкой. Присваивание по срезу, последняя операция в предыдущем примере, заменяет целый сегмент списка за один шаг. Из-за некоторой сложности для лучшего понимания ее можно воспринимать как комбинацию двух шагов. 

1. Удаление. Секция, указанная слева от знака =, удаляется. 

2. Вставка. Новые элементы, содержащиеся в итерируемом объекте справа от знака =, вставляются в список слева в месте, где была удалена старая секция.

Вызовы списковых методов

Еще один распространенный метод, sort, упорядочивает список на месте; он использует стандартные критерии сравнения Python (здесь строковые сравнения, но он применим к любому типу) и по умолчанию сортирует в возрастающем порядке. Модифицировать поведение сортировки можно путем передачи ключевых аргументов — специального синтаксиса “имя=значение” в вызовах функций, который указывает передачу по имени и часто применяется для задания параметров конфигурации.

В методе sort аргумент reverse позволяет делать сортировку в убывающем порядке вместо возрастающего, a key задает функцию с одним аргументом, которая возвращает значение, подлежащее использованию при сортировке

Одно предостережение: помните о том, что append и sort изменяют ассоциированный списковый объект на месте, но не возвращают список в качестве результата (формально оба метода возвращают значение None). Если вы запишете что-то вроде L=L. append (X), то не получите модифицированное значение L (на самом деле вы вообще утратите ссылку на список!). Когда используются такие атрибуты, как append и sort, объекты изменяются в форме побочного эффекта, поэтому нет причин присваивать повторно.

Отчасти из-за таких ограничений в последних версиях Python сортировка также доступна в виде встроенной функции, которая сортирует любую коллекцию (не только списки) и возвращает в качестве результата новый список (вместо изменений на месте): 

```python
>» L = [’abc’, 'ABD', ’аВе’] 

>» sorted(L, key-str.lower, reverse-True) # Встроенная функция сортировки 

[’аВе’, ’ABD’, 'abc'] 

»> L = [’abc’, ’ABD’, ’аВе'] 

»> sorted([х.lower() for х in L] , reverse=True) # Предварительно трансформирует # элементы: отличается! 

['abe', 'abd', ’abc’]
```

Другие распространенные списковые операции
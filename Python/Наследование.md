Наследование - создание нового класса на основе уже существующего. Новый класс наследует все атрибуты и методы  от родительского класса. Такой приём позволяет избежать дублирования кода в [[python]].

В дочернем классе можно переопределить методы и атрибуты родительского [[class]]а или добавить новые.

Наследование в действии:

```python
class Father:
    pass

class Son(Father):
    pass
```

Проверить, унаследован ли класс от другого класса, можно с помощью функции issubclass():

```python
issubclass(Son, Father)
True
```

Дочерний класс является уточненной версией родительского. Можно сказать, что Son() является Father()

```python
class Father():
    def say(self):
        print("I'm a man")

class Son(Father):
    pass

son = Son()
son.say()
I'm a man!
```

Переопределение методов работает так:

```python
class Son(Father):
    def say(self):
        print("Hello!")
```

Переопределять можно любые методы, включая init()
В производный класс можно добавить и метод, которого не было в родительском классе.

если нужно будет вызвать этот родительский метод - [[super()]]

```python
class Person():
    def __init__(self, name):
        self.name = name
```

Обратите внимание на то, что вызов метод __init__() в следующем подклассе
имеет дополнительный параметр email:

```python
class EmailPerson(Person):
    def __init__(self, name, email):
        super().__init__(name)
        self.email = email
```
        
Строка self.email = email — это новый код, который отличает класс EmailPerson от класса Person.

Мы использовали метод super(), чтобы заставить Person делать свою работу так же, как это делает обычный объект класса Person. Есть и другое преимущество: если определение класса Person в будущем изменится, с помощью метода super() мы сможем гарантировать, что атрибуты и методы, которые класс EmailPerson наследует от класса Person, отреагируют на изменения. Используйте метод [[super()]], когда потомок делает что-то по-своему, но все еще нуждается в помощи родителя.